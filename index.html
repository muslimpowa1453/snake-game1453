<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wormate Clone - Render Connected</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0b0b12; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }

        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }

        #minimap-container { position: absolute; top: 20px; left: 20px; width: 150px; height: 150px; background: rgba(0,0,0,0.5); border-radius: 50%; border: 3px solid #333; overflow: hidden; }
        #minimap { width: 100%; height: 100%; }

        #stats-ui { position: absolute; top: 180px; left: 20px; color: white; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px black; background: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 8px; }
        #stats-ui span { color: #ffd700; margin-left: 5px; }

        #status-box { position: absolute; top: 220px; left: 20px; display: flex; flex-direction: column; gap: 5px; }
        .buff { background: rgba(0,0,0,0.6); color: white; padding: 5px 10px; border-radius: 15px; font-size: 12px; font-weight: bold; border-left: 5px solid; display: none; align-items: center; }
        
        #leaderboard { position: absolute; top: 20px; right: 20px; width: 200px; background: rgba(0,0,0,0.6); color: white; padding: 15px; border-radius: 10px; }
        #leaderboard h3 { margin: 0 0 10px 0; text-align: center; color: #ffd700; }
        .lb-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; }
        .lb-me { color: #00ff00; font-weight: bold; }

        #clock-display { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 20px; color: white; font-size: 20px; font-weight: bold; }

        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; flex-direction: column; justify-content: center; align-items: center; color: white; pointer-events: auto; z-index: 100; }
        .menu-btn { padding: 15px 40px; font-size: 24px; color: white; border: none; border-radius: 30px; cursor: pointer; margin: 10px; font-weight: bold; transition: transform 0.2s; }
        .btn-green { background: #00cc66; }
        .btn-blue { background: #3366ff; }
        .menu-btn:hover { transform: scale(1.1); }

        #lobby { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(11,11,18,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; }
        #lobby h1 { font-size: 60px; color: #ffd700; margin-bottom: 20px; text-shadow: 0 0 20px #ff9900; }
        #nickname-input { padding: 15px; border-radius: 30px; border: 2px solid #444; background: #222; color: white; font-size: 20px; text-align: center; margin-bottom: 20px; outline: none; width: 250px; }
    </style>
</head>
<body>

    <canvas id="game"></canvas>

    <div id="lobby">
        <h1>WORMATE CLONE</h1>
        <input type="text" id="nickname-input" placeholder="Nickname" value="Player" maxlength="12">
        <button class="menu-btn btn-green" onclick="startGame()">PLAY</button>
        <div id="status-msg" style="color:white; margin-top:10px; font-size:14px; opacity:0.8;"></div>
    </div>

    <div id="ui-layer">
        <div id="minimap-container"><canvas id="minimap"></canvas></div>
        <div id="stats-ui">Score: <span id="score-val">0</span> | Kills: <span id="kill-val">0</span></div>
        
        <div id="status-box">
            <div id="buff-x2" class="buff" style="border-color:#ff9900">2x SCORE</div>
            <div id="buff-x5" class="buff" style="border-color:#ff3300">5x SCORE</div>
            <div id="buff-x10" class="buff" style="border-color:#ff0066">10x SCORE</div>
            <div id="buff-ae" class="buff" style="border-color:#00ffcc">CUTTING EDGE</div>
            <div id="buff-spd" class="buff" style="border-color:#aa00ff">SPEED</div>
        </div>

        <div id="leaderboard">
            <h3>Leaderboard</h3>
            <div id="lb-content"></div>
        </div>
        <div id="clock-display">00:00</div>
    </div>

    <div id="game-over">
        <h1 style="font-size:50px; color:#ff3333;">GAME OVER</h1>
        <p style="font-size:24px;">Length: <span id="final-score" style="color:#ffd700;">0</span></p>
        <button class="menu-btn btn-green" onclick="location.reload()">Play Again</button>
    </div>

    <script>
        // ========================================================
        // HARDCODED SERVER URL (FIX)
        // ========================================================
        const SERVER_URL = "wss://snake-server-3bnw.onrender.com";
        // ========================================================

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const miniCanvas = document.getElementById("minimap");
        const miniCtx = miniCanvas.getContext("2d");

        let ws;
        let myId = null;
        let isGameRunning = false;
        let reconnectAttempts = 0;
        const MAX_RETRIES = 10;
        
        let serverState = { players: {}, bots: [], food: [] };
        let entities = {}; 

        let mouse = { x: 0, y: 0 };
        let boosting = false;

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            miniCanvas.width = 150;
            miniCanvas.height = 150;
        }
        window.addEventListener("resize", resize);
        resize();

        window.addEventListener("mousemove", e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener("mousedown", () => boosting = true);
        window.addEventListener("mouseup", () => boosting = false);

        function startGame() {
            const name = document.getElementById("nickname-input").value || "Guest";
            document.getElementById("lobby").style.display = "none";
            document.getElementById("status-msg").innerText = "Connecting to Render Server...";
            connect(name);
        }

        function connect(playerName) {
            reconnectAttempts++;
            const statusMsg = document.getElementById("status-msg");
            
            // Only show status in lobby UI if we haven't started game yet
            if(!document.getElementById("lobby").style.display || document.getElementById("lobby").style.display === 'none') {
                 // We are in game or transition, alert instead
            } else {
                statusMsg.innerText = `Connecting... Attempt ${reconnectAttempts}/${MAX_RETRIES}`;
            }

            try {
                ws = new WebSocket(SERVER_URL);
                
                ws.onopen = () => { 
                    console.log("Connected to " + SERVER_URL); 
                    reconnectAttempts = 0; 
                    statusMsg.innerText = "";
                    
                    // Hide lobby, show game if not already showing
                    if(document.getElementById("ui-layer").style.display === 'none') {
                        document.getElementById("ui-layer").style.display = "block";
                        document.getElementById("lobby").style.display = "none";
                    }
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleMessage(data);
                };
                
                ws.onclose = () => {
                    if (!isGameRunning) {
                        console.log("Connection closed. Retrying...");
                        if (reconnectAttempts < MAX_RETRIES) {
                            setTimeout(() => connect(playerName), 2000); 
                        } else {
                            alert("Connection failed. The server might be asleep or down.");
                            location.reload();
                        }
                    } else {
                        // Disconnect during game
                        alert("Disconnected from server.");
                        location.reload();
                    }
                };

                ws.onerror = (err) => {
                    console.error("WS Error:", err);
                    statusMsg.innerText = "Connection Error. Retrying...";
                };
                
                setInterval(sendInput, 1000/30);

            } catch(e) {
                console.error(e);
                if (reconnectAttempts < MAX_RETRIES) setTimeout(() => connect(playerName), 2000);
                else alert("Critical connection error.");
            }
        }

        function sendInput() {
            if (!ws || ws.readyState !== WebSocket.OPEN || !myId) return;
            const dx = mouse.x - canvas.width/2;
            const dy = mouse.y - canvas.height/2;
            const angle = Math.atan2(dy, dx);

            ws.send(JSON.stringify({
                type: 'input',
                angle: angle,
                boost: boosting,
                name: entities[myId] ? entities[myId].name : "" 
            }));
        }

        function handleMessage(data) {
            if (data.type === 'init') {
                myId = data.id;
                document.getElementById("ui-layer").style.display = "block";
                document.getElementById("lobby").style.display = "none";
                isGameRunning = true;
                
                const name = document.getElementById("nickname-input").value;
                entities[data.id] = { 
                    ...data, 
                    localX: 0, localY: 0, localA: 0, 
                    name: name 
                };
                loop();
            }
            else if (data.type === 'state') {
                serverState = data;
                updateLocalEntities();
            }
            else if (data.type === 'die') {
                if (data.id === myId) {
                    triggerGameOver();
                } else {
                    delete entities[data.id];
                }
            }
        }

        function updateLocalEntities() {
            serverState.players.forEach(p => {
                if (!entities[p.id]) {
                    entities[p.id] = { ...p };
                } else {
                    const ent = entities[p.id];
                    const lerp = 0.2; 
                    
                    ent.localX = ent.localX + (p.x - ent.localX) * lerp;
                    ent.localY = ent.localY + (p.y - ent.localY) * lerp;
                    ent.localA = ent.localA + shortestAngle(ent.localA, p.a) * lerp;
                    
                    ent.length = p.l;
                    ent.path = p.p;
                    ent.buffs = p.b;
                    ent.kills = p.k;
                    ent.color = p.c;
                    ent.name = p.n;
                }
            });

            serverState.bots.forEach(b => {
                if (!entities[b.id]) {
                    entities[b.id] = { ...b };
                } else {
                    const ent = entities[b.id];
                    const lerp = 0.2;
                    ent.localX = ent.localX + (b.x - ent.localX) * lerp;
                    ent.localY = ent.localY + (b.y - ent.localY) * lerp;
                    ent.localA = ent.localA + shortestAngle(ent.localA, b.a) * lerp;
                    ent.length = b.l;
                    ent.path = b.p;
                    ent.color = b.c;
                    ent.name = b.n;
                }
            });
        }

        function shortestAngle(a, b) {
            const d = b - a;
            return (d + Math.PI) % (Math.PI * 2) - Math.PI;
        }

        function triggerGameOver() {
            isGameRunning = false;
            document.getElementById("game-over").style.display = "flex";
            const me = entities[myId];
            document.getElementById("final-score").innerText = Math.floor(me ? me.length : 0);
            ws.close();
        }
        
        function draw() {
            ctx.fillStyle = "#0b0b12";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!myId || !entities[myId]) return;

            const me = entities[myId];
            const camX = me.localX || me.x || 0; 
            const camY = me.localY || me.y || 0;

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            const zoom = Math.max(0.3, 1 - (me.length / 5000));
            ctx.scale(zoom, zoom);
            ctx.translate(-camX, -camY);

            drawGrid(camX, camY);
            drawFood();

            for (const id in entities) {
                if (id !== myId) drawSnake(entities[id]);
            }
            drawSnake(me, true);

            ctx.restore();
            drawUI(me);
        }

        function drawGrid(cx, cy) {
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.beginPath();
            const size = 100;
            const range = 1000;
            const startX = Math.floor((cx - range) / size) * size;
            const endX = Math.floor((cx + range) / size) * size;
            const startY = Math.floor((cy - range) / size) * size;
            const endY = Math.floor((cy + range) / size) * size;

            for(let x=startX; x<=endX; x+=size) {
                ctx.moveTo(x, cy-range); ctx.lineTo(x, cy+range);
            }
            for(let y=startY; y<=endY; y+=size) {
                ctx.moveTo(cx-range, y); ctx.lineTo(cx+range, y);
            }
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0,0,6000,0,Math.PI*2);
            ctx.strokeStyle = "#333";
            ctx.lineWidth = 50;
            ctx.stroke();
        }

        function drawFood() {
            const me = entities[myId];
            if(!me) return;
            for (const f of serverState.food) {
                if (Math.abs(f.x - me.localX) > 1500 && Math.abs(f.y - me.localY) > 1500) continue;
                ctx.fillStyle = f.color;
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
                ctx.fill();
            }
        }

        function drawSnake(s, isMe) {
            if (!s.path) return;
            const radius = getRadius(s.length);
            ctx.fillStyle = s.color;
            
            for (let i = s.path.length - 1; i >= 0; i-=2) { 
                const p = s.path[i];
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
                ctx.fill();
            }

            const headX = s.localX || s.x;
            const headY = s.localY || s.y;
            const headA = s.localA || s.a;

            ctx.fillStyle = s.color;
            ctx.beginPath();
            ctx.arc(headX, headY, radius, 0, Math.PI*2);
            ctx.fill();

            drawFace(headX, headY, headA, radius);

            if (!isMe) {
                ctx.fillStyle = "white";
                ctx.font = "12px Arial";
                ctx.textAlign = "center";
                ctx.fillText(s.name, headX, headY - radius - 10);
            }
        }

        function drawFace(x, y, angle, r) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(r*0.3, -r*0.3, r*0.35, 0, Math.PI*2); 
            ctx.arc(r*0.3, r*0.3, r*0.35, 0, Math.PI*2);  
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(r*0.35, -r*0.3, r*0.1, 0, Math.PI*2);
            ctx.arc(r*0.35, r*0.3, r*0.1, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        function drawUI(me) {
            document.getElementById("score-val").innerText = Math.floor(me.length * 10);
            document.getElementById("kill-val").innerText = me.kills || 0;
            
            const now = Date.now();
            const buffs = me.buffs || {};
            toggleBuff("buff-x2", buffs.x2, now);
            toggleBuff("buff-x5", buffs.x5, now);
            toggleBuff("buff-x10", buffs.x10, now);
            toggleBuff("buff-ae", buffs.ae, now);
            toggleBuff("buff-spd", buffs.spd, now);

            miniCtx.fillStyle = "rgba(0,0,0,0.8)";
            miniCtx.fillRect(0,0,150,150);
            for(const id in entities) {
                const e = entities[id];
                if(!e.localX) continue;
                const mx = 75 + (e.localX / 6000) * 75;
                const my = 75 + (e.localY / 6000) * 75;
                miniCtx.fillStyle = (id === myId) ? "white" : e.color;
                miniCtx.beginPath();
                miniCtx.arc(mx, my, id === myId ? 3 : 2, 0, Math.PI*2);
                miniCtx.fill();
            }

            const list = Object.values(entities).sort((a,b) => b.length - a.length).slice(0,10);
            let html = "";
            list.forEach((p, i) => {
                const cls = (p.id === myId) ? "lb-row lb-me" : "lb-row";
                html += `<div class="${cls}"><span>#${i+1} ${p.name}</span><span>${Math.floor(p.length*10)}</span></div>`;
            });
            document.getElementById("lb-content").innerHTML = html;

            const d = new Date();
            document.getElementById("clock-display").innerText = 
                d.getHours().toString().padStart(2,'0') + ":" + d.getMinutes().toString().padStart(2,'0');
        }

        function toggleBuff(id, expiry, now) {
            document.getElementById(id).style.display = (now < expiry) ? "flex" : "none";
        }

        function getRadius(len) {
            const minR = 10; 
            const maxR = 40;
            const base = Math.log10(Math.max(len, 50));
            const t = Math.min(1, Math.max(0, (base - 1.7) / 3.5));
            return minR + (maxR - minR) * t;
        }

        function loop() {
            if (!isGameRunning) return;
            requestAnimationFrame(loop);
            draw();
        }
    </script>
</body>
</html>
