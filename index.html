<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wormate.io Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1e272e; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Connecting Status */
        #status-msg {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: #fab1a0; padding: 5px 15px;
            border-radius: 20px; font-weight: bold; font-size: 14px;
            display: none; pointer-events: auto;
        }

        /* Login Screen */
        #login-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
            backdrop-filter: blur(2px);
        }
        .login-box {
            background: #fff; padding: 30px; border-radius: 20px;
            text-align: center; box-shadow: 0 0 30px rgba(0,0,0,0.5);
            width: 320px; border: 4px solid #ff7675;
        }
        .login-box h1 { margin: 0 0 20px; color: #d63031; text-transform: uppercase; font-weight: 900; font-size: 28px; }
        input { 
            padding: 12px; font-size: 18px; border: 2px solid #dfe6e9; 
            border-radius: 30px; width: 80%; margin-bottom: 15px; outline: none; text-align: center;
            transition: border 0.3s;
        }
        input:focus { border-color: #ff7675; }
        button {
            padding: 12px 40px; font-size: 20px; border: none; border-radius: 30px;
            background: linear-gradient(to bottom, #ff7675, #d63031);
            color: white; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 0 #b71540;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 0 0 #b71540; }

        /* HUD */
        .hud-panel { padding: 15px; pointer-events: auto; }
        #score-board { 
            color: white; text-shadow: 2px 2px 0 #000; 
            font-size: 24px; font-weight: 900; 
            background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 15px;
            display: inline-block;
        }
        #leaderboard { 
            background: rgba(0,0,0,0.6); color: white; padding: 10px; 
            border-radius: 10px; min-width: 180px; text-align: right;
            margin-top: 10px; margin-right: 10px;
            float: right; border: 2px solid rgba(255,255,255,0.1);
        }
        .lb-row { font-size: 14px; margin-bottom: 4px; display: flex; justify-content: space-between; font-weight: bold; }
        .lb-me { color: #ffeaa7; text-shadow: 0 0 5px orange; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="status-msg">Connecting to server...</div>

        <!-- Top HUD -->
        <div class="hud-panel">
            <div id="score-board">Weight: <span>0</span> kg</div>
            <div id="leaderboard">
                <div style="text-align: center; border-bottom: 2px solid rgba(255,255,255,0.2); margin-bottom: 5px; padding-bottom: 5px; font-weight: 800;">TOP WORMS</div>
                <div id="lb-content"></div>
            </div>
        </div>

        <!-- Login Overlay -->
        <div id="login-overlay">
            <div class="login-box">
                <h1>Wormate Clone</h1>
                <input type="text" id="nickname" placeholder="Nickname" maxlength="12">
                <br>
                <button id="play-btn">PLAY</button>
                <p style="font-size: 12px; color: #636e72; margin-top: 15px;">Use Mouse to Move â€¢ Click/Space to Boost</p>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Configuration ---
        const CONFIG = {
            serverUrl: 'wss://snake-server-3bnw.onrender.com', // Your Render URL
            gridSize: 50,
            baseScale: 1.0,
            minScale: 0.4
        };

        // --- Canvas Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- Game State ---
        let ws;
        let myId = null;
        let players = {};
        let food = [];
        let camera = { x: 0, y: 0, z: 1 };
        let isPlaying = false;
        let isBoosting = false;

        // --- Visuals (The Wormate Look) ---
        const Drawing = {
            drawGrid: (camX, camY, zoom) => {
                const step = CONFIG.gridSize * zoom;
                const offX = (-camX * zoom) % step;
                const offY = (-camY * zoom) % step;

                ctx.fillStyle = '#2d3436'; // Dark background
                ctx.fillRect(0, 0, width, height);

                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)'; // Very subtle grid

                for (let x = offX; x < width; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
                for (let y = offY; y < height; y += step) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
                ctx.stroke();
            },

            drawSweet: (x, y, r, type, color) => {
                ctx.save();
                ctx.translate(x, y);
                
                // Wormate uses Procedural "Sweets"
                switch(type) {
                    case 0: // Donut
                        ctx.beginPath();
                        ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.beginPath(); ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2); ctx.fillStyle = '#2d3436'; ctx.fill(); // Hole
                        // Icing
                        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath(); ctx.arc(0, 0, r * 0.7, 0, Math.PI); ctx.stroke();
                        break;
                    case 1: // Cake Slice (Triangle)
                        ctx.beginPath();
                        ctx.moveTo(0, -r); ctx.lineTo(r * 0.8, r * 0.8); ctx.lineTo(-r * 0.8, r * 0.8);
                        ctx.closePath();
                        ctx.fillStyle = color; ctx.fill();
                        // Cream layer
                        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fillRect(-r*0.2, -r*0.2, r*0.4, r*0.3);
                        break;
                    case 2: // Gingerbread / Cookie
                        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fillStyle = '#cd6133'; // Cookie color
                        ctx.fill();
                        // Chips
                        ctx.fillStyle = '#5d4037';
                        ctx.beginPath(); ctx.arc(-r*0.3, -r*0.3, r*0.2, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.arc(r*0.2, r*0.2, r*0.25, 0, Math.PI*2); ctx.fill();
                        break;
                    default: // Candy Ball
                        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2);
                        ctx.fillStyle = color; ctx.fill();
                        // Shine
                        ctx.fillStyle = 'rgba(255,255,255,0.4)';
                        ctx.beginPath(); ctx.arc(-r*0.3, -r*0.3, r*0.3, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();
            },

            drawWorm: (p, isMe) => {
                if (!p.path || p.path.length === 0) return;
                const head = p.path[p.path.length - 1];
                
                // 1. Draw Body (Striped)
                ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                
                // Shadow/Outline
                ctx.beginPath();
                p.path.forEach((pt, i) => i===0 ? ctx.moveTo(pt.x, pt.y) : ctx.lineTo(pt.x, pt.y));
                ctx.lineWidth = p.width + 4; ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.stroke();

                // Inner Color
                ctx.beginPath();
                p.path.forEach((pt, i) => i===0 ? ctx.moveTo(pt.x, pt.y) : ctx.lineTo(pt.x, pt.y));
                ctx.lineWidth = p.width; ctx.strokeStyle = p.color; ctx.stroke();
                
                // 2. Head (Eyes & Face)
                ctx.save();
                ctx.translate(head.x, head.y);
                ctx.rotate(p.angle);
                
                // Face base (slight oval)
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(0, 0, p.width/1.8, 0, Math.PI*2); ctx.fill();

                // Eyes
                const eyeOff = p.width / 2.8;
                const eyeSize = p.width / 3.0;
                
                // Whites
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.arc(eyeOff, -eyeOff/1.5, eyeSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(eyeOff, eyeOff/1.5, eyeSize, 0, Math.PI*2); ctx.fill();
                
                // Pupils (Black)
                ctx.fillStyle = 'black';
                const pSize = eyeSize / 2;
                // If isMe, look at mouse? For now, fixed forward looks cleaner
                ctx.beginPath(); ctx.arc(eyeOff + 2, -eyeOff/1.5, pSize, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(eyeOff + 2, eyeOff/1.5, pSize, 0, Math.PI*2); ctx.fill();

                ctx.restore();

                // Name
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Segoe UI';
                ctx.textAlign = 'center';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3;
                ctx.strokeText(p.name, head.x, head.y - p.width - 10);
                ctx.fillText(p.name, head.x, head.y - p.width - 10);
            }
        };

        // --- Network ---
        function connect() {
            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'block';
            statusEl.innerText = "Connecting to Render server...";

            ws = new WebSocket(CONFIG.serverUrl);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                console.log("Connected!");
                statusEl.style.display = 'none';
            };

            ws.onerror = (e) => {
                console.log("Connection error. Server might be waking up.");
                statusEl.innerText = "Server is waking up (might take 30s)...";
            };

            ws.onclose = () => {
                console.log("Disconnected");
                statusEl.innerText = "Disconnected. Reconnecting...";
                statusEl.style.display = 'block';
                setTimeout(connect, 3000); // Auto reconnect
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'init') {
                    myId = msg.selfId;
                } else if (msg.type === 'update') {
                    players = msg.players;
                    food = msg.food;
                    updateHUD(msg.players);
                    
                    if (players[myId]) {
                        const me = players[myId];
                        // Smooth Camera
                        camera.x += (me.x - camera.x) * 0.1;
                        camera.y += (me.y - camera.y) * 0.1;
                        // Zoom out as you grow
                        const targetZ = Math.max(CONFIG.minScale, CONFIG.baseScale - (me.score / 10000));
                        camera.z += (targetZ - camera.z) * 0.02;
                    }
                } else if (msg.type === 'dead') {
                    alert(`Game Over! Weight: ${Math.floor(msg.score)}kg`);
                    location.reload(); 
                }
            };
        }

        // --- Controls ---
        function sendInput(angle, boost) {
            if (ws && ws.readyState === 1 && isPlaying) {
                ws.send(JSON.stringify({ type: 'input', angle: angle, boost: boost }));
            }
        }

        document.addEventListener('mousemove', (e) => {
            if (!isPlaying) return;
            const cx = width / 2;
            const cy = height / 2;
            const angle = Math.atan2(e.clientY - cy, e.clientX - cx);
            sendInput(angle, isBoosting);
        });

        const setBoost = (state) => {
            if (isBoosting !== state) {
                isBoosting = state;
                // Resend input immediately to register boost start/end
                // We need the last known angle, but keeping it simple relies on mousemove
            }
        };

        document.addEventListener('mousedown', () => setBoost(true));
        document.addEventListener('mouseup', () => setBoost(false));
        document.addEventListener('keydown', (e) => { if(e.code === 'Space') setBoost(true); });
        document.addEventListener('keyup', (e) => { if(e.code === 'Space') setBoost(false); });

        document.getElementById('play-btn').addEventListener('click', () => {
            const name = document.getElementById('nickname').value || "Worm";
            if (ws && ws.readyState === 1) {
                ws.send(JSON.stringify({ type: 'join', name: name }));
                document.getElementById('login-overlay').style.display = 'none';
                isPlaying = true;
            } else {
                alert("Still connecting to server... please wait.");
            }
        });

        // --- Loop ---
        function render() {
            ctx.clearRect(0, 0, width, height);

            ctx.save();
            ctx.translate(width/2, height/2);
            ctx.scale(camera.z, camera.z);
            ctx.translate(-camera.x, -camera.y);

            Drawing.drawGrid(camera.x, camera.y, camera.z);

            // Draw Food
            // Only draw visible food for performance
            const viewW = width / camera.z;
            const viewH = height / camera.z;
            food.forEach(f => {
                if (Math.abs(f.x - camera.x) < viewW && Math.abs(f.y - camera.y) < viewH) {
                    Drawing.drawSweet(f.x, f.y, f.r, f.type, f.color);
                }
            });

            // Draw Players (Me on top)
            Object.values(players).sort((a,b) => (a.id === myId ? 1 : -1)).forEach(p => {
                Drawing.drawWorm(p, p.id === myId);
            });

            ctx.restore();
            requestAnimationFrame(render);
        }

        function updateHUD(list) {
            // Score
            if (list[myId]) document.querySelector('#score-board span').innerText = Math.floor(list[myId].score);
            
            // Leaderboard
            const sorted = Object.values(list).sort((a,b) => b.score - a.score).slice(0, 10);
            document.getElementById('lb-content').innerHTML = sorted.map((p, i) => 
                `<div class="lb-row ${p.id === myId ? 'lb-me' : ''}">
                    <span>#${i+1} ${p.name.substring(0,12)}</span>
                    <span>${Math.floor(p.score)}</span>
                </div>`
            ).join('');
        }

        // Init
        connect();
        render();
    </script>
</body>
</html>
