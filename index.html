<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Wormate Clone - Multiplayer (Server Authoritative + Bots)</title>
<style>
  body{margin:0;overflow:hidden;background:#0b0b12;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}
  canvas{display:block}
  #ui-layer{position:absolute;inset:0;pointer-events:none;display:none}
  #minimap-container{position:absolute;top:20px;left:20px;width:150px;height:150px;background:rgba(0,0,0,0.5);border-radius:50%;border:3px solid #333;overflow:hidden;pointer-events:auto;box-shadow:0 0 10px rgba(0,0,0,0.5)}
  #stats-ui{position:absolute;top:180px;left:20px;color:#fff;font-size:16px;font-weight:700;text-shadow:1px 1px 2px #000;background:rgba(0,0,0,0.4);padding:5px 10px;border-radius:8px;border:1px solid #444}
  #stats-ui span{color:#ffd700;margin-left:5px}
  #leaderboard{position:absolute;top:20px;right:20px;width:220px;background:rgba(0,0,0,0.6);color:#fff;padding:15px;border-radius:10px}
  #leaderboard h3{margin:0 0 10px 0;text-align:center;color:#ffd700}
  .lb-row{display:flex;justify-content:space-between;margin-bottom:5px;font-size:14px}
  .lb-me{color:#00ff00;font-weight:700}
  #clock-display{position:absolute;top:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.5);padding:10px 20px;border-radius:20px;color:#fff;font-size:20px;font-weight:700;border:1px solid #444}
  #fps-box{position:absolute;bottom:10px;right:10px;color:#00ff00;font-family:monospace;font-size:14px;background:rgba(0,0,0,0.5);padding:5px 10px;border-radius:5px}
  #lobby{position:absolute;inset:0;background:rgba(11,11,18,0.95);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:200}
  #lobby h1{font-size:60px;color:#ffd700;margin-bottom:10px;text-shadow:0 0 20px #ff9900}
  #nickname-input{padding:15px;border-radius:30px;border:2px solid #444;background:#222;color:#fff;font-size:20px;text-align:center;margin-bottom:20px;outline:none;width:250px}
  #game-over{position:absolute;inset:0;background:rgba(0,0,0,0.85);display:none;flex-direction:column;justify-content:center;align-items:center;color:#fff;pointer-events:auto;z-index:100}
  #game-over h1{font-size:50px;color:#ff3333;margin-bottom:20px}
  .menu-btn{padding:15px 40px;font-size:24px;color:#fff;border:none;border-radius:30px;cursor:pointer;transition:transform .2s;font-weight:700}
  .btn-green{background:#00cc66}
  .btn-green:hover{transform:scale(1.1);background:#00ee77}
  .btn-blue{background:#3366ff}
  .btn-blue:hover{transform:scale(1.1);background:#5588ff}
  .btn-group{display:flex;gap:20px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<canvas id="minimap" style="display:none"></canvas>
<audio id="hs-audio" src="https://wormx.store/video/hs_2.mp3"></audio>

<div id="lobby">
  <h1>WORMATE CLONE</h1>
  <input type="text" id="nickname-input" placeholder="Nickname" value="Player" maxlength="12">
  <button class="menu-btn btn-green" onclick="startGame()">PLAY</button>
</div>

<div id="ui-layer">
  <div id="minimap-container"><canvas id="minimap2" width="150" height="150"></canvas></div>
  <div id="stats-ui">Kills: <span id="kill-count">0</span> | HS: <span id="hs-count">0</span></div>
  <div id="clock-display">00:00</div>
  <div id="leaderboard">
    <h3>Leaderboard <span id="online-count">(0 online)</span></h3>
    <div id="lb-content"></div>
  </div>
  <div id="fps-box">FPS: 60</div>
</div>

<div id="game-over">
  <h1>GAME OVER</h1>
  <p style="font-size:24px;margin-bottom:30px;">Score: <span id="final-score" style="color:#ffd700;">0</span></p>
  <div class="btn-group">
    <button class="menu-btn btn-blue" onclick="goHome()">Home</button>
    <button class="menu-btn btn-green" onclick="restartGame()">Play Again</button>
  </div>
</div>

<script>
/* ================= SERVER ================= */
const SERVER_URL = "wss://snake-server-3bnw.onrender.com";

let ws = null;
let myId = null;
let entities = {}; // id -> player/bot snapshot
let rules = { mapRadius: 6000, underRatio: 0.60, hsNeckMult: 2.2, hsHitMult: 0.60 };

/* ================= CANVAS ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: true, desynchronized: true });

const minimapCanvas = document.getElementById("minimap2");
const miniCtx = minimapCanvas.getContext("2d", { desynchronized: true });

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

/* ================= CONFIG ================= */
const SEGMENT_SPACING = 5;
const PATH_SPACING = 1;

const BASE_SPEED = 2.0;
const MANUAL_BOOST_ADD = 2.2;

const TURN_SPEED_WIDE = 0.075;
const TURN_SPEED_BOOST = 0.12;

let zoom = 1.0;

/* ================= LOCAL PLAYER (INPUT ONLY) ================= */
let isGameRunning = false;
let isGameOver = false;

let playerName = "Player";
let playerColor = "#ff66cc";

let head = { x: 0, y: 0, angle: 0 };
let length = 50;
let path = [];

let startTime = 0;
let lastTime = performance.now();
let frameCount = 0;
let lastFpsUpdate = 0;

let killCount = 0;
let hsCount = 0;

let mouse = { x: canvas.width / 2, y: canvas.height / 2 };
let boosting = false;

window.addEventListener("mousemove", e => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener("mousedown", () => boosting = true);
window.addEventListener("mouseup", () => boosting = false);

window.addEventListener("wheel", e => {
  zoom -= e.deltaY * 0.001;
  zoom = Math.max(0.3, Math.min(1.5, zoom));
}, { passive: true });

/* ================= NET ================= */
function connectToServer() {
  if (ws) ws.close();
  ws = new WebSocket(SERVER_URL);

  ws.onopen = () => console.log("Connected");

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);

    if (data.type === "init") {
      myId = data.selfId;
      if (data.rules) rules = data.rules;
    }

    if (data.type === "state") {
      const map = {};
      for (const p of data.players) {
        if (!p.alive) continue;
        map[p.id] = p;

        if (p.id === myId) {
          killCount = p.killCount || 0;
          hsCount = p.hsCount || 0;
          updateStatsUI();
          // keep our server color stable
          playerColor = p.color || playerColor;
        }
      }
      entities = map;

      const onlineEl = document.getElementById("online-count");
      if (onlineEl) onlineEl.innerText = `(${Object.keys(map).length} online)`;
    }

    if (data.type === "death") {
      if (data.id === myId) {
        triggerGameOver();
      }

      // HS sound if we killed
      if (data.reason === "hs" && data.killerId === myId) {
        const audio = document.getElementById("hs-audio");
        if (audio) { audio.currentTime = 0; audio.play().catch(()=>{}); }
      }
    }

    if (data.type === "respawn") {
      head.x = data.x;
      head.y = data.y;
      head.angle = data.angle;
      length = data.length;

      path = [];
      for (let i = 0; i < length * SEGMENT_SPACING; i += SEGMENT_SPACING) {
        path.push({ x: head.x, y: head.y });
      }

      isGameOver = false;
      isGameRunning = true;
      startTime = Date.now();
      document.getElementById("game-over").style.display = "none";
    }
  };

  ws.onclose = () => console.log("Disconnected");
  ws.onerror = (err) => console.error("WS Error:", err);
}

/* ================= UI ================= */
function startGame() {
  playerName = document.getElementById("nickname-input").value.trim() || "Player";
  document.getElementById("lobby").style.display = "none";
  document.getElementById("ui-layer").style.display = "block";

  connectToServer();

  // local temp init (server will keep us updated)
  head.x = 0; head.y = 0; head.angle = Math.random() * Math.PI * 2;
  length = 50;
  path = [];
  for (let i = 0; i < length * SEGMENT_SPACING; i += SEGMENT_SPACING) path.push({ x: head.x, y: head.y });

  isGameRunning = true;
  isGameOver = false;
  startTime = Date.now();
}

function restartGame() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "respawn" }));
  }
}

function goHome() {
  document.getElementById("game-over").style.display = "none";
  document.getElementById("ui-layer").style.display = "none";
  document.getElementById("lobby").style.display = "flex";
  isGameRunning = false;
  if (ws) ws.close();
}

function updateStatsUI() {
  document.getElementById("kill-count").innerText = killCount;
  document.getElementById("hs-count").innerText = hsCount;
}

function triggerGameOver() {
  if (isGameOver) return;
  isGameOver = true;
  isGameRunning = false;
  document.getElementById("final-score").innerText = Math.floor(length * 10);
  document.getElementById("game-over").style.display = "flex";
}

/* ================= UTILS ================= */
function lerpAngle(a, b, t) {
  let diff = b - a;
  while (diff < -Math.PI) diff += Math.PI * 2;
  while (diff > Math.PI) diff -= Math.PI * 2;
  return a + diff * t;
}
function getWormRadius(len) {
  const minR = 11, maxR = 20;
  const t = Math.min(1, Math.max(0, (len - 40) / 260));
  return minR + (maxR - minR) * (1 - Math.pow(1 - t, 2));
}
function applyWormShadow(ctx, r) {
  ctx.shadowBlur = r * 2.2;
  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = 0;
}

/* ================= UPDATE (movement only) ================= */
function update(dt) {
  if (!isGameRunning || isGameOver) return;

  const now = Date.now();
  const elapsed = Math.floor((now - startTime) / 1000);
  document.getElementById("clock-display").innerText =
    `${String(Math.floor(elapsed / 60)).padStart(2,"0")}:${String(elapsed % 60).padStart(2,"0")}`;

  // input turning
  const dx = mouse.x - canvas.width / 2;
  const dy = mouse.y - canvas.height / 2;
  const dist = Math.hypot(dx, dy);

  if (dist > 20) {
    const targetAngle = Math.atan2(dy, dx);
    let turn = boosting ? TURN_SPEED_BOOST : TURN_SPEED_WIDE;
    head.angle = lerpAngle(head.angle, targetAngle, Math.min(0.35, turn * dt));
  }

  // movement
  let speed = BASE_SPEED + (boosting ? MANUAL_BOOST_ADD : 0);
  head.x += Math.cos(head.angle) * speed * dt;
  head.y += Math.sin(head.angle) * speed * dt;

  const last = path[path.length - 1];
  if (!last || Math.hypot(head.x - last.x, head.y - last.y) >= PATH_SPACING) {
    path.push({ x: head.x, y: head.y });
  }
  const maxPath = length * SEGMENT_SPACING + 150;
  if (path.length > maxPath) path.splice(0, path.length - maxPath);

  // send movement
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "move", x: head.x, y: head.y, angle: head.angle, length, path, name: playerName }));
  }

  updateLeaderboardUI();
}

/* ================= DRAW ================= */
function drawSegmentOverlay(ctx, x, y, r) {
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.arc(x - r * 0.25, y, r * 0.92, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawWormateFace(ctx, x, y, angle, r) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);

  const eyeX = r * 0.35;
  const eyeY = r * 0.28;
  const eyeR = r * 0.35;

  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = Math.max(2, r * 0.12);

  ctx.beginPath(); ctx.arc(eyeX, -eyeY, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.arc(eyeX,  eyeY, eyeR, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

  ctx.fillStyle = "black";
  const pupilR = eyeR * 0.28;
  ctx.beginPath();
  ctx.arc(eyeX + eyeR * 0.15, -eyeY, pupilR, 0, Math.PI * 2);
  ctx.arc(eyeX + eyeR * 0.15,  eyeY, pupilR, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "#e43b3b";
  ctx.lineWidth = Math.max(2, r * 0.14);
  ctx.lineCap = "round";
  const mouthX = r * 0.55;
  const mouthR = r * 0.55;
  ctx.beginPath();
  ctx.arc(mouthX, 0, mouthR, -0.55, 0.55);
  ctx.stroke();

  ctx.restore();
}

function drawSnake(p, visibleW, visibleH) {
  if (Math.abs(p.x - head.x) > visibleW && Math.abs(p.y - head.y) > visibleH) return;

  const dxB = p.x - head.x;
  const dyB = p.y - head.y;
  const distB = Math.hypot(dxB, dyB);

  const maxDrawSegments = distB > 2000 ? Math.min(p.length, 25) :
                          distB > 1200 ? Math.min(p.length, 60) :
                          p.length;

  const r = getWormRadius(p.length || 50);
  const smoothPath = [...(p.path || []), { x: p.x, y: p.y }];
  const pts = [];
  let curr = 0;
  let target = SEGMENT_SPACING;

  for (let j = smoothPath.length - 1; j > 0; j--) {
    const a = smoothPath[j], b = smoothPath[j-1];
    const d = Math.hypot(a.x - b.x, a.y - b.y);
    while (curr + d >= target) {
      const t = (target - curr) / d;
      pts.push({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
      target += SEGMENT_SPACING;
      if (pts.length >= maxDrawSegments) break;
    }
    curr += d;
    if (pts.length >= maxDrawSegments) break;
  }

  const doShadow = distB < 1600;

  ctx.fillStyle = p.color || "#00ff00";
  for (let i = pts.length - 1; i >= 0; i--) {
    const pt = pts[i];
    ctx.save();
    if (doShadow) applyWormShadow(ctx, r);
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
    if (distB < 1600) drawSegmentOverlay(ctx, pt.x, pt.y, r);
  }

  // head
  ctx.save();
  if (doShadow) applyWormShadow(ctx, r);
  ctx.beginPath();
  ctx.arc(p.x, p.y, r * 1.08, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  drawWormateFace(ctx, p.x, p.y, p.angle || 0, r);
}

function drawMinimap() {
  miniCtx.fillStyle = "rgba(20,20,30,0.8)";
  miniCtx.fillRect(0,0,150,150);

  miniCtx.strokeStyle = "rgba(255,255,255,0.3)";
  miniCtx.beginPath();
  miniCtx.moveTo(0,75); miniCtx.lineTo(150,75);
  miniCtx.moveTo(75,0); miniCtx.lineTo(75,150);
  miniCtx.stroke();

  const scale = 150 / (rules.mapRadius * 2);
  const cx = 75, cy = 75;

  for (const p of Object.values(entities)) {
    const mx = cx + p.x * scale;
    const my = cy + p.y * scale;
    miniCtx.fillStyle = p.color || "#fff";
    miniCtx.beginPath();
    miniCtx.arc(mx, my, 2, 0, Math.PI*2);
    miniCtx.fill();
  }

  if (!isGameOver) {
    const px = cx + head.x * scale;
    const py = cy + head.y * scale;
    miniCtx.fillStyle = "white";
    miniCtx.beginPath();
    miniCtx.arc(px, py, 3, 0, Math.PI*2);
    miniCtx.fill();
    miniCtx.strokeStyle = "black";
    miniCtx.stroke();
  }
}

function updateLeaderboardUI() {
  const list = Object.values(entities).map(p => ({ name: p.name || "?", score: Math.floor((p.length||0)*10) }));
  list.push({ name: playerName, score: Math.floor(length*10), isMe:true });
  list.sort((a,b)=>b.score-a.score);

  const lb = document.getElementById("lb-content");
  lb.innerHTML = list.slice(0,10).map((p,i)=>
    `<div class="${p.isMe?'lb-row lb-me':'lb-row'}"><span>#${i+1} ${p.name}</span><span>${p.score}</span></div>`
  ).join("");
}

function draw() {
  ctx.fillStyle = "#0b0b12";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!isGameRunning) return;

  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.scale(zoom, zoom);
  ctx.translate(-head.x, -head.y);

  // map
  ctx.beginPath();
  ctx.arc(0,0,rules.mapRadius,0,Math.PI*2);
  ctx.strokeStyle="#ff3333";
  ctx.lineWidth=20;
  ctx.stroke();
  ctx.fillStyle="#161621";
  ctx.fill();

  // grid
  ctx.save();
  ctx.clip();
  ctx.strokeStyle="#2a2a35";
  ctx.lineWidth=1;
  ctx.beginPath();
  const gridStep=100;
  const visibleW = canvas.width/zoom;
  const visibleH = canvas.height/zoom;
  const viewLeft = head.x - visibleW/2 - 100;
  const viewRight= head.x + visibleW/2 + 100;
  const viewTop  = head.y - visibleH/2 - 100;
  const viewBottom=head.y + visibleH/2 + 100;

  const startX = Math.max(-rules.mapRadius, Math.floor(viewLeft / gridStep) * gridStep);
  const endX   = Math.min(rules.mapRadius, Math.ceil(viewRight / gridStep) * gridStep);
  const startY = Math.max(-rules.mapRadius, Math.floor(viewTop / gridStep) * gridStep);
  const endY   = Math.min(rules.mapRadius, Math.ceil(viewBottom / gridStep) * gridStep);

  for (let i=startX;i<=endX;i+=gridStep){ ctx.moveTo(i,-rules.mapRadius); ctx.lineTo(i,rules.mapRadius); }
  for (let i=startY;i<=endY;i+=gridStep){ ctx.moveTo(-rules.mapRadius,i); ctx.lineTo(rules.mapRadius,i); }
  ctx.stroke();
  ctx.restore();

  // draw all server entities
  for (const p of Object.values(entities)) drawSnake(p, visibleW, visibleH);

  // draw myself
  drawSnake({ x: head.x, y: head.y, angle: head.angle, length, color: playerColor, name: playerName, path }, visibleW, visibleH);

  drawMinimap();
  ctx.restore();
}

/* ================= LOOP ================= */
function loop() {
  requestAnimationFrame(loop);

  const now = performance.now();
  let dt = (now - lastTime) / (1000/60);
  lastTime = now;
  if (dt > 10) dt = 1;

  frameCount++;
  if (now - lastFpsUpdate >= 1000) {
    const fps = Math.round((frameCount * 1000) / (now - lastFpsUpdate));
    document.getElementById("fps-box").innerText = "FPS: " + fps;
    lastFpsUpdate = now;
    frameCount = 0;
  }

  update(dt);
  draw();
}
loop();
</script>
</body>
</html>
